import plotly.plotly as py
import plotly.graph_objs as go
from itertools import chain
import numpy as np
import re

randseq = "TCGGATGGTGTCGGATGAAGGTGACTGGTGAGTACATGGTGAGAACTGATGGATACAGGTGCTGGGAGAGGGGTGTAAGATACAAGGTCGGATGATATGCTGGAATAGCGGTGGTAACAGGTGTCACCGAGAGGTGTGAGATGATGATGAGTCGGATAAACAGGTGTTGTGGACGCAACATTCGGAGGTGCTTGGTGAGAGGTGAGACGATACTCGGTGGTGTAAGGTGTCGGAGCTGAGATTGGTACCTTGGGTGAGTGGATCAAGTCAAGGTGAGAGGGGAACAGGCTGGGTCGGAGAGAACATGGTGTCGAACAGGTGCAAGGATTGGGCTGGGTAAGTACATGAACGCATGGGTCTGGTGTAATAAGTGGTAGGATCATGGTGAGGTGTCAGCGATACATTAATCGGTCTTGGTGATATCAAGCCGATTATGGTGCCGTGTTCGGTGCAAGCTAGAACGGAGTATCAAGGTGAGGTGATCAGGTGTCGGAGGATCTCGGTGTTCTATAAGGTGTCGTGTCGAGGTGTACGAATCGGGGTACATGGGTCTTGGGCAACTGGATCACATATGAGTCGGTCAACTCGGGAAGTACTGAGTGGCGATAAGGCGATACTCAAGGTGAGTACAGGTGCTCAAGCACGATCTGCCACGAACGAACTTGGGTGTACATGTCAGATGTAAACGTGGATAAGGTGTGGTGAACTTCGAGGTGTACATAGCAACATTAAGGTGTCGCGAACGAATCAAGCTACATATGAGACCAGATGGAATGAGTGGAACAGGGTGACTGGAACGAAAGGTGATCAAGGTGACAGGTGTGGATACATTGGGATATAAACGAATCGGTGTGGTGACAGACGTTCGGTGGCAAGGTGTACGTGAGAGGTGATGCTAAAGTGGCGAAAGTATGGGAGTACGTGGATCTGGTGAGTACCGAGTAGTAGGGTGAGGTGAACAACAGGTGAGAGGTGTGGATAAGTGTAATAAGGTGAGGTGCAAGCATGGTACAAGGGTAAGTGAGTCGGGTATTAAATTGGGTAACGAAATAGTGGTACTGGTGGGGAGTACGGTACAACATTCTCAAGTAAGTACATGATATATGAAACTGACATATGTAAGGTGTGGAACAAACATGGGTAAGAATGAGTGGTGTCCTGGAGAGGTGACAGGTGAGTAAGTAACAGGTGATACAAGAAGGTGTCGGGAACATGAGTGTAAAGGGGTGGGGTGCTGGTGAGGTGTGGATATGTCAAACAAGGTGTGGTATAAGGTGAGAGGTGAGGTGACAGGCAAACATGAGTTCAACAAGGTGTCAACAACTCGGTGAGAGCTGGATGGTGCTGAGAGGTGTTGGATCGAGGTGAACAAGCCAGATGAATGAGAGGTGAGCGGACGTAGATAGGACAGACGAAGAAGGTGCGTACGCAAGGTGATAAGCAAGGGTGATGAGAGACAGGTGTACGGGTGAGACGAACTGGTGTCAAGTATCAAGCAAGGTGAGAGTATGAGAGGTGTCAAGGTGAAGGGGTCAACCGGTGTACGGGCGAGGTGTCCTGGTGGCGAGGTGCTGGTGGCTGGTAGCAACAGGTGTTCGGATACGAACATAGATCCGGTGAGTAGTTCTAGCTACAACAGGTGAGTGGGTCAAAGAACGACGTGGAATTGAGTCGGTGGCAACAAGGTGAGTCGGACATATGAAGAACGAATGAGAACAAGGTGCAAGCGAGAGAGGTGTCTGCTGACATGAGATCAAGGTGTGTCAAACAAGTGGTGTGGCAAGGTGAACTGAGTGGGTCGAGATATCCGGTGGTGAGTGTAAGTAAACAAACGTGTCATGGTGTCCGGTGGCCAGATAAGGTGTTCGGTGAGGTGCAACAGACGTTCAAGGCTGGATTGGCAACAGACGTACAGGCGATAAGGTGAGGTGTCGGTGGGGTGATTGGACATGGATGGGGTGGGGGGTGTAGACGGGTGTGTCAAGTGGTGTCAGGTGTCCTGGTATATGGTCAGCACGACGAACAGGTGAAGAATCAAGGTGTCAAGATATCGGAGGTGTCCGTGTACGGTACGAGAGGTGTGGATATAAGGTGTGGTGTCAGGAACGAACATTATGGGTCTCTGCCGTGTTATTAAGGTGTTAAAATTGGAACCGTGTTTCAAGATGGTACATATCGGTGTACATGAGAGGTGAGGACATTGGGTGTTCTGGTGCAACCATGGTGTGAACGTGTATGATGGAGACAGGTGAACTGAGAGGTGAGAGAGTTCGGATCCGCGAACATCGCGATCAAGAGTTCGGTACTTAAAAGTAATTAAGTGATGGTGAGGTGAGTGGTAACATTCAAGGTGTGTCGGTGTGGCGAACCAAGCTGGGTCGAACAAGGAACAAGGTGAGGTGAACAGGTGCACAGGTGAGCTGGGTGGCCGCGATTCAAGTGTCACGACCGGTACAGGTGATAGATGGGTGTCAAGAGACAGGTGTTGATATGGTGAGGTGAAAGTGTTCTGGAATTCGGTGAGAGTGTTCGGGTGTGTGTCGAAAGGTGTCAAATCAAGTGAGAGCGGTACAGGTGTTAAACGCTGGATATCGGAATAAACATTAACTGAGCGGGATATGCGATCAACAGGTGTCAAGGCAACAAGCGAACCGGGTAGATCAAGGTGAGGTGAGGGTCAAGGTGTGGTGAGAGGTGCAAGGTGTACGTAAACCACCGGTGAACGAAACATATGGGTAGGATCGGTGAACAAGGTGTGGAACATTCAAGTCGGTGTGCTATGGAATGGTGAGCGATACATATGACGTGTCAGGTGAAACTTCTGGTAAGTACGCTGGTGGCGCGAGGTGACGAACATTCGGAGGTGTAAGGTGTGGAATAGGGTGAACAAACATGTCAAAGGTGTTCGGATGAGATGATTAAGGTGTAAGAACTGGTGTGGACAGGATGGTCGGAACGTACGCAACAGTGTCGGAGACCGAGATATCAACAGCAACATGATTCGGTGTGGCAAGGAATTGGGTGAGTATGGATATGATAGATATGTCAAGACGTGGGGGTGTTGAACAGGTGTCGGTCAGGTGAGGTGTCGGTGCTGTAACCGATGAGACGGTGAGGTGTAGACGGGTGAGAGTAGGGTGCTACATGGTGTTGGTGTCAAGTCAAAGTAGGATCACGACTGAGCTTGGTGGCTCGGATATTGAGTGGCTGAGAGGTGTGAACGATTTACAAGGTGTTTAAACAGGTGAGAGAGGGTGTGCTGGGTGAGAGAGTCGGTCGGGTACGAATTAAGGTGTGTGGCATGAACGAATAAGAATGAGAGACGAAAGGTGATGAGAGTACATGTGGCCTGGAACATGGGTAGACGTTCGGATCTCGGGTGAACTGACAACCGAGAACAGGTGTCAAACACGAACAGGTGCGATTACAACACGAAGGTGAGTCAGAGACGGGTGTCTGGAACAAGGTGTGGTGAGGGGTCGGGGTGTGGTGTTGGGGCGAACTGAGGGTCAGGTGAGGTGCTACGCGAGGTGAGCTCATGGGTGAGGTGCATGGGGAGCGGTGAGGTGTAAGGTGCGCGATCAACTCGGAGAGCAAGGTGTCAAGGTGAGTGGTGTACCGAGGACTGGATATTCTATCAGGTGCTAGCGGTGTTAAAGGTGTGTGTCATGAAGGGGTGACAGACGATCAGGTGTCGGACAACTACTGATGAGTAACAGGTGAGGTGCTACAAACAGGTGTATTGGTCAGGAGAGTATCGGAGAGGTGTAATACAAGGTGTGAGAGTGGATCGGTGGGTATCAAGTGGTGTGAACGGTGTGTCGGGGGTGTGAGAGGTGTGGTACAAGGTGAGGTGCGCAACAACAGGTGCCGATTCTAGGACATCAGGTGAGGTGTTATTAAAGTGACAGGTGTAAGGTGTTTCGAGGTGTCACAGGTGAGAGGATATAACCGTGACAGGTGACATGGGTGTGTCACAGGTGCTGGAGCTGATATACAAGGTGTTCACCGAACAGGTGAGCTTCTGCAAGGTGACATGATACAAAGCGGAACCGGATATGTGGCTGGACGGTGTATAAGACGAAGGTGAGGTGACCGAACATTCGGAACGATAAGGTGTCGTGGATCGGTGCTGACAGATACCGAACGAAGGTGTAGGGGTCAACAGGTGCTATGGTACGGCGATACGCGAGGTGTGGTGCATTCTACCAAGGTGAGTCAAGGTGACTTGGGTACAGGTGCTCAAAGGTGTCTTGGGTGAGGTGTACATGAGGGGAGGGGATACATTCAAGGTGCCGGTGTGGAATGACAGGAGCGGGTACCACGAGGTGAGGTGTCAACTGAGTATGAAGAGAGTAGATAAGGTGTTGAACATGAGTTCGGGTCGGGTCTGTAAGTACAGGTGACATATGAGCGGATCAAGAGTTTCTATCGGATCAAAGTGGGTACACGATGATAAGTCGGGTACCAAGGTGAGACGGTGTCGGACCGATATGAGCTGGCATGGTGTATGGTGAGTGGCAAGGTGTTGCTGGTGGTGTACGAAAGGTGTGTCGGGTGCACAGGTGAATGATCAAGCAAGGTGAACCGTGAGTGCTGGGTCAACACGAGGTGAGAGGTGTGGACGAACACTGATACAACGAACAGGCGATGATAAGTAGTGGGGTGGGGCGAGGTGCTGGTCAAGGTGAGGTGAACATGAGACTGACATAACTTCAAGGGCTGGCGAAGACGAACAGGGTGACCGATACGAAGGTGTGGGGAACTTTCTACCGATACGAAGGTGAGAGGTGCTGCTACCCACGAGGTGTGGATAAGGTGATGATCGGTGCGCGATGATTGGTGAGGTGTTTCGAGTCGGAGGTGTCAACTGAGGTGAGGAATCGGGGGTGTCGAGAACCGATAAGCTGGAGCTAAGTATGAGAACACAGGTGAGGTGTACAACAGGAGTACGGAACACGAGGTGAGGTGAGCTCGGTGGTGAACGATATTGTAAGGCA"
oligoList =["TATTC", "ACACG", "CGATT", "ACGCA", "ATCGA"]

#input: a genome sequence
#output: a clean genome sequence
#given a genome sequence this looks for typos and whitespaces and deletes them to make 1 clean sequence
def cleanSeq(gen):
	gen = gen.upper()
	gen = re.sub('[BDEFHIJKLMNOPQRSUVWXYZ]', '', gen)
	gen = "".join(gen.split())
	return gen

#input: a genome sequence string, a wanted BlockSize integer, and a offset integer.
#output: a list of blocks incremented by the offset.
#this function takes a genome sequence and makes a list of all blocks of a given block size
def parseSeq(gen,blockSize, offset):
	#prints given genome
	#print "Unaltered given genome(could contain typos): " + gen
	#create list
	blockList = []
	#looks for typos and errors in genome
	gen = cleanSeq(gen)
	genLen = len(gen)
	offsetEnd = genLen - blockSize
	print ("Altered Genome (removes typos and whitespace): " + gen)
	print ("\n")
	#raise error is block is larger then the genome length
	if blockSize > genLen:
		raise ValueError("block cannot be larger then the genome")
	#if block is equal to gen size return gen
	if blockSize == genLen:
		blockList.append(gen)
		print ("Your List of blocks in step size " + str(blockSize) + " is ", blockList)
	#adds blocks to the list
	else:
		for i in range(0, offsetEnd + 1, offset):
			blockList.append(gen[i:i+blockSize])
		print ("Your List of blocks in step size " + str(blockSize) + " is", blockList)
	return blockList

#input: a list of oligos
#output: returns oligo list with oligos that have front and mismatches 
def errors(oligoLis):
	bases = ['A', 'C', 'G', 'T']
	
	oligoListERR = []
	oligoListERR.extend(oligoLis)
	for code in oligoLis:
		for start_el in bases:
			for end_el in bases:
				oligoListERR.append(start_el + code[1:-1] + end_el)
	for code in oligoListERR:
		for el in oligoLis:
			if code != el:
				code = code + " mismatch"

	return oligoListERR

#Input: a genome Sequence string, a list of oligos, the length of the oligo
#Output: a dictionary of the matches and the mtch position.
#goes through list of blocks and prints a dictionary of where the oligos match
def oligoBindingSites(gen, oligoLis, oligoLen):
	blockList = parseSeq(gen, oligoLen, 1)
	numBlocks = len(blockList)
	keys = list(range(1,numBlocks+1))
	numKeys = len(keys)
	new_dict = dict(zip(keys, blockList))
	print("\n")
	oligoMatches = {k: v for k, v in new_dict.items() if v in oligoLis}
	oligoMatches = sorted(oligoMatches.items())
	#print "Your matches are at positions: ", oligoMatches
	return oligoMatches

def visualizeOligoMatches(gen, oligoLis, oligoLen):
	error = errors(oligoLis)
	bindingSitesMismatch = oligoBindingSites(gen, error, oligoLen)
	print ("your binding sites with mismatches are", bindingSitesMismatch)
	x1,y1 = zip(*bindingSitesMismatch)
	trace = go.Scatter(
		x = x1,
		y = y1,
		mode = 'markers'
	)
	data = [trace]
	py.iplot(data, filename='basic-scatter')
visualizeOligoMatches(randseq, oligoList, 5)
